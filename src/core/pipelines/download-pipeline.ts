import { ChunkSource, DeltaService, ReconstructionService, ValidationService } from '../services';
import { HashStorageAdapter, UrlStorageAdapter } from '../adapters';
import { ChunkUrlInfo, DeltaPlan, RDIndex } from '../models';
import { RacDeltaConfig } from '../config';
import { Nullish } from '../types';

export enum UpdateStrategy {
  /**
   * Downloads every chunk before reconstruction and save chunks in memory.
   * Perfect for fast connection and offline reconstruction.
   *
   * NOTE: For large updates this is not recommended, as could use a lot of memory
   */
  DownloadAllFirstToMemory = 'download-all-first-to-memory',

  /**
   * Downloads chunks on demand while reconstruction.
   * Useful for limited resourced environments or progressive streaming.
   */
  StreamFromNetwork = 'stream-from-network',

  /**
   * Downloads every chunk before reconstruction and save chunks in disk to given path.
   * Perfect for fast connection, fast disks and offline reconstruction.
   */
  DownloadAllFirstToDisk = 'download-all-first-to-disk',
}

export interface DownloadOptions {
  /**
   * If true, downloads everything.
   * If false, only new and modified chunks will be downloaded.
   */
  force?: Nullish<boolean>;

  /**
   * Path where chunks will be saved if `DownloadAllFirstToDisk` strategy is set.
   */
  chunksSavePath?: Nullish<string>;

  /**
   * If true, will search first an existing rd-index in local dir.
   * This option is not recommended, as generating a new rd-index is always the best way to detect changes or corruption.
   */
  useExistingIndex?: Nullish<boolean>;

  /**
   * How many files will be reconstructed concurrently. (Default is 5)
   */
  fileReconstructionConcurrency?: Nullish<number>;

  /**
   * Minimum file size (in bytes) required to perform an **in-place reconstruction** instead of using a temporary file.
   * Default: `400 * 1024 * 1024` (400 MB).
   *
   * **In-place reconstruction:**
   * The existing file is opened and updated directly by overwriting only the modified or missing chunks.
   *
   * **.tmp reconstruction:**
   * The file is fully rebuilt in a temporary `.tmp` location using all chunks (new and existing), then replaced over the original file.
   *
   * **When to use:**
   * In-place reconstruction is recommended for **large files**, as it avoids rewriting the entire file and significantly reduces disk space usage.
   * However, it may be **unsafe for certain formats** (e.g., ZIP archives or databases) that are sensitive to partial writes or corruption.
   * To disable in-place reconstruction entirely, set this value to `0`.
   */
  inPlaceReconstructionThreshold?: Nullish<number>;

  /**
   * Optional callback to inform progress.
   */
  onProgress?: (
    type: 'download' | 'deleting' | 'reconstructing',
    progress: number,
    diskUsage?: Nullish<number>,
    speed?: Nullish<number>
  ) => void;

  /**
   * Optinal callback for state changes.
   */
  onStateChange?: (state: 'downloading' | 'reconstructing' | 'cleaning' | 'scanning') => void;
}

export abstract class DownloadPipeline {
  protected updateProgress(
    value: number,
    state: 'download' | 'reconstructing' | 'deleting',
    diskUsage?: Nullish<number>,
    speed?: Nullish<number>,
    options?: Nullish<DownloadOptions>
  ) {
    options?.onProgress?.(state, value, diskUsage, speed);
  }

  protected changeState(
    state: 'downloading' | 'reconstructing' | 'cleaning' | 'scanning',
    options?: Nullish<DownloadOptions>
  ) {
    options?.onStateChange?.(state);
  }

  /**
   * This method will create a rd-index.json of a given directory, scanning files and generating hashes.
   *
   * @param dir directory to generate index.
   */
  abstract loadLocalIndex(dir: string): Promise<RDIndex>;

  /**
   * This method will find for a rd-index.json if exists on given folder.
   *
   * @param localDir directory to find index.
   */
  abstract findLocalIndex(localDir: string): Promise<RDIndex | null>;

  /**
   * This method will save the new local index on given folder.
   *
   * @param localDir directory to save index.
   * @param index the rd-index.json object.
   */
  abstract saveLocalIndex(localDir: string, index: RDIndex): Promise<void>;

  /**
   * This method will check for reconstructed files, verifying its hash and obsolete chunks.
   * If obsolete chunks are still present, it will delete them, and reconstruct file again if needed.
   *
   * @param plan the `DeltaPlan` generated by delta.compare of the two rd-index.json for the download
   * @param localDir directory to check files
   * @param remoteIndex the remote index for reference
   * @param chunkSource `ChunkSource` to download corrupt chunks in case of invalid files.
   */
  abstract verifyAndDeleteObsoleteChunks(
    plan: DeltaPlan,
    localDir: string,
    remoteIndex: RDIndex,
    chunkSource: ChunkSource,
    options?: Nullish<DownloadOptions>
  ): Promise<{ deletedFiles: string[]; verifiedFiles: string[]; rebuiltFiles: string[] }>;
}

export abstract class HashDownloadPipeline extends DownloadPipeline {
  constructor(
    protected readonly storage: HashStorageAdapter,
    protected readonly delta: DeltaService,
    protected readonly reconstruction: ReconstructionService,
    protected readonly validation: ValidationService,
    protected readonly config: RacDeltaConfig
  ) {
    super();
  }

  abstract execute(
    localDir: string,
    strategy: UpdateStrategy,
    remoteIndex?: Nullish<RDIndex>,
    options?: Nullish<DownloadOptions>
  ): Promise<void>;

  /**
   * This method will download first all needed chunks for download, and save them temporary on disk or memory.
   *
   * Will return `ChunkSource`, ChunkSources will be needed to reconstruct files, this method will ONLY return
   * memory or disk chunk sources for offline reconstruction, if you use a storage like S3, you can omit this
   * and use directly the StorageChunkSource with `reconstruction.reconstructAll()` if you prefer.
   *
   * (Using StorageChunkSource will download chunks and reconstruct file at same time, concurrently)
   *
   * @param plan the `DeltaPlan` generated by delta.compare of the two rd-index.json for the download
   * @param target disk or memory, where chunks will be saved temporary
   * @param options
   */
  abstract downloadAllMissingChunks(
    plan: DeltaPlan,
    target: 'memory' | 'disk',
    options?: Nullish<DownloadOptions>
  ): Promise<ChunkSource>;
}

export abstract class UrlDownloadPipeline extends DownloadPipeline {
  constructor(
    protected readonly storage: UrlStorageAdapter,
    protected readonly reconstruction: ReconstructionService,
    protected readonly validation: ValidationService,
    protected readonly delta: DeltaService,
    protected readonly config: RacDeltaConfig
  ) {
    super();
  }

  abstract execute(
    localDir: string,
    urls: {
      downloadUrls: Record<string, ChunkUrlInfo>;
      indexUrl: string;
    },
    strategy: UpdateStrategy,
    plan?: Nullish<DeltaPlan>,
    options?: Nullish<DownloadOptions>
  ): Promise<void>;
  abstract downloadAllMissingChunks(
    downloadUrls: Record<string, ChunkUrlInfo>,
    target: 'memory' | 'disk',
    options?: Nullish<DownloadOptions>
  ): Promise<ChunkSource>;
}
